<!DOCTYPE html>
<html>
<head>
    <title>MS-15 Drawing Testing</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <h1>MS-15 Drawing Module Tests</h1>
    <div id="results"></div>
    
    <!-- Test containers -->
    <div style="display: none;">
        <div id="test-canvas-container"></div>
        <div id="test-toolbar"></div>
        <div id="name-canvas-toolbar"></div>
        <div id="name-canvas-container"></div>
        <div id="class-canvas-toolbar"></div>
        <div id="class-canvas-container"></div>
    </div>

    <script src="js/drawing.js"></script>
    <script>
        // MS-15: Drawing module comprehensive testing
        const results = document.getElementById('results');
        
        function log(message) {
            results.innerHTML += message + '<br>';
            console.log(message);
        }
        
        function runTest(name, testFn) {
            try {
                const result = testFn();
                log(`✅ ${name}: PASS`);
                return true;
            } catch (error) {
                log(`❌ ${name}: FAIL - ${error.message}`);
                return false;
            }
        }
        
        log('MS-15 Drawing Module Apple Pencil & Canvas Tests:');
        let testsPassed = 0;
        let testsTotal = 0;
        
        function test(name, fn) {
            testsTotal++;
            if (runTest(name, fn)) testsPassed++;
        }
        
        // Clear instances for clean testing
        Drawing.canvasInstances.clear();
        
        // Test 1: Canvas Initialization
        log('<h2>1. Canvas Creation & Initialization:</h2>');
        
        test('Canvas area initialization', () => {
            const result = Drawing.initCanvasArea('test-canvas-container', 300, 200);
            
            if (!result) {
                throw new Error('initCanvasArea returned null');
            }
            
            const { canvas, ctx } = result;
            if (!(canvas instanceof HTMLCanvasElement)) {
                throw new Error('Canvas not created properly');
            }
            
            if (!ctx || typeof ctx.beginPath !== 'function') {
                throw new Error('Canvas context not initialized');
            }
            
            if (canvas.width !== 300 || canvas.height !== 200) {
                throw new Error(`Canvas dimensions wrong: ${canvas.width}x${canvas.height}, expected 300x200`);
            }
            
            return true;
        });
        
        test('Canvas instance tracking', () => {
            if (!Drawing.canvasInstances.has('test-canvas-container')) {
                throw new Error('Canvas instance not tracked');
            }
            
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            if (!instance.canvas || !instance.ctx) {
                throw new Error('Canvas instance data incomplete');
            }
            
            return true;
        });
        
        test('Invalid container handling', () => {
            const result = Drawing.initCanvasArea('nonexistent-container', 100, 100);
            if (result !== null) {
                throw new Error('Should return null for invalid container');
            }
            return true;
        });
        
        test('Canvas styling and properties', () => {
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const canvas = instance.canvas;
            
            // Check touch-action styling for iPad
            if (canvas.style.touchAction !== 'none') {
                throw new Error('Touch-action not set correctly for iPad');
            }
            
            // Check context properties
            const ctx = instance.ctx;
            if (ctx.lineCap !== 'round' || ctx.lineJoin !== 'round') {
                throw new Error('Canvas context not configured properly');
            }
            
            return true;
        });
        
        // Test 2: Drawing Tools & State Management
        log('<h2>2. Drawing Tools & State Management:</h2>');
        
        test('Tool switching functionality', () => {
            // Test pen tool
            Drawing.setTool('pen');
            if (Drawing.currentTool !== 'pen') {
                throw new Error('Pen tool not set correctly');
            }
            
            // Test eraser tool
            Drawing.setTool('eraser');
            if (Drawing.currentTool !== 'eraser') {
                throw new Error('Eraser tool not set correctly');
            }
            
            return true;
        });
        
        test('Canvas context updates with tool changes', () => {
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const ctx = instance.ctx;
            
            // Test pen mode
            Drawing.setTool('pen');
            if (ctx.globalCompositeOperation !== 'source-over') {
                throw new Error('Pen mode not applied to canvas context');
            }
            
            // Test eraser mode
            Drawing.setTool('eraser');
            if (ctx.globalCompositeOperation !== 'destination-out') {
                throw new Error('Eraser mode not applied to canvas context');
            }
            
            return true;
        });
        
        test('Color and width settings', () => {
            Drawing.setPenColor('#ff0000');
            if (Drawing.penColor !== '#ff0000') {
                throw new Error('Pen color not set correctly');
            }
            
            Drawing.setPenWidth(5);
            if (Drawing.penWidth !== 5) {
                throw new Error('Pen width not set correctly');
            }
            
            // Check if canvas contexts are updated
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const ctx = instance.ctx;
            Drawing.setTool('pen'); // Ensure pen mode
            
            if (ctx.strokeStyle !== '#ff0000') {
                throw new Error('Canvas context stroke style not updated');
            }
            
            return true;
        });
        
        test('Eraser width scaling', () => {
            Drawing.setPenWidth(3);
            Drawing.setTool('eraser');
            
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const ctx = instance.ctx;
            
            if (ctx.lineWidth !== 9) { // 3 * 3
                throw new Error(`Eraser width scaling wrong: got ${ctx.lineWidth}, expected 9`);
            }
            
            return true;
        });
        
        // Test 3: Event Handling & Touch Support
        log('<h2>3. Event Handling & Touch Support:</h2>');
        
        test('Mouse event listeners attached', () => {
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const canvas = instance.canvas;
            
            // Check if mouse events are properly attached
            const listeners = getEventListeners ? getEventListeners(canvas) : null;
            
            // Alternative check: trigger synthetic events and verify handling
            const mousedownEvent = new MouseEvent('mousedown', {
                clientX: 50,
                clientY: 50,
                bubbles: true,
                cancelable: true
            });
            
            // Should not throw error
            canvas.dispatchEvent(mousedownEvent);
            
            return true;
        });
        
        test('Touch event prevention and conversion', () => {
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const canvas = instance.canvas;
            
            const touchEvent = new TouchEvent('touchstart', {
                touches: [{
                    clientX: 100,
                    clientY: 100,
                    target: canvas
                }],
                bubbles: true,
                cancelable: true
            });
            
            // Should not throw error and should prevent default
            let defaultPrevented = false;
            try {
                canvas.dispatchEvent(touchEvent);
                // If we get here without error, touch handling is working
            } catch (error) {
                throw new Error('Touch event handling failed: ' + error.message);
            }
            
            return true;
        });
        
        test('Coordinate calculation accuracy', () => {
            const mockEvent = {
                target: {
                    getBoundingClientRect: () => ({ left: 10, top: 20, width: 300, height: 200 }),
                    width: 600,  // Canvas internal width
                    height: 400  // Canvas internal height
                },
                clientX: 160,  // 10 + 150
                clientY: 120   // 20 + 100
            };
            
            const point = Drawing.getCanvasPoint(mockEvent);
            
            // Expected: (150 * 2, 100 * 2) = (300, 200) due to scaling
            if (Math.abs(point.x - 300) > 1 || Math.abs(point.y - 200) > 1) {
                throw new Error(`Coordinate calculation wrong: got (${point.x}, ${point.y}), expected (300, 200)`);
            }
            
            return true;
        });
        
        // Test 4: Canvas Operations
        log('<h2>4. Canvas Operations & Data Management:</h2>');
        
        test('Canvas clearing functionality', () => {
            // First, simulate some drawing by directly modifying canvas
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const ctx = instance.ctx;
            
            // Draw something
            ctx.beginPath();
            ctx.moveTo(10, 10);
            ctx.lineTo(50, 50);
            ctx.stroke();
            
            // Clear canvas
            Drawing.clearCanvas('test-canvas-container');
            
            // Check if canvas is cleared by getting image data
            const imageData = ctx.getImageData(0, 0, instance.canvas.width, instance.canvas.height);
            const data = imageData.data;
            
            // Check if all pixels are transparent (alpha = 0)
            let isCleared = true;
            for (let i = 3; i < data.length; i += 4) { // Check alpha channel
                if (data[i] !== 0) {
                    isCleared = false;
                    break;
                }
            }
            
            if (!isCleared) {
                throw new Error('Canvas not cleared properly');
            }
            
            return true;
        });
        
        test('Data export as Base64', () => {
            const dataURL = Drawing.getCanvasData('test-canvas-container');
            
            if (!dataURL) {
                throw new Error('getCanvasData returned null');
            }
            
            if (!dataURL.startsWith('data:image/')) {
                throw new Error('Invalid data URL format');
            }
            
            return true;
        });
        
        test('Data loading from Base64', () => {
            // Create a simple data URL (1x1 red pixel)
            const testDataURL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChAGA2J1A0gAAAABJRU5ErkJggg==';
            
            // Should not throw error
            try {
                Drawing.loadCanvasData('test-canvas-container', testDataURL);
            } catch (error) {
                throw new Error('loadCanvasData failed: ' + error.message);
            }
            
            return true;
        });
        
        test('Invalid container operations', () => {
            // These should not throw errors, just handle gracefully
            Drawing.clearCanvas('nonexistent-container');
            
            const data = Drawing.getCanvasData('nonexistent-container');
            if (data !== null) {
                throw new Error('Should return null for nonexistent container');
            }
            
            Drawing.loadCanvasData('nonexistent-container', 'data:image/png;base64,test');
            // Should complete without error
            
            return true;
        });
        
        // Test 5: Toolbar Creation & Management
        log('<h2>5. Toolbar Creation & Tool Management:</h2>');
        
        test('Drawing toolbar creation', () => {
            Drawing.createDrawingToolbar('test-toolbar');
            
            const toolbar = document.querySelector('#test-toolbar .drawing-toolbar');
            if (!toolbar) {
                throw new Error('Toolbar not created');
            }
            
            // Check for required buttons
            const penBtn = toolbar.querySelector('[title="Stift"]');
            const eraserBtn = toolbar.querySelector('[title="Radiergummi"]');
            const clearBtn = toolbar.querySelector('[title="Löschen"]');
            
            if (!penBtn || !eraserBtn || !clearBtn) {
                throw new Error('Required toolbar buttons not found');
            }
            
            return true;
        });
        
        test('Tool-specific canvas operations', () => {
            // Create another canvas for specific tool testing
            Drawing.initCanvasArea('name-canvas-container', 300, 40);
            Drawing.createDrawingToolbar('name-canvas-toolbar');
            
            // Test tool switching for specific canvas
            Drawing.setToolForCanvas('eraser', 'name-canvas-container');
            
            const instance = Drawing.canvasInstances.get('name-canvas-container');
            if (instance.ctx.globalCompositeOperation !== 'destination-out') {
                throw new Error('Tool not applied to specific canvas');
            }
            
            return true;
        });
        
        test('Toolbar button state management', () => {
            Drawing.setToolForCanvas('pen', 'name-canvas-container');
            
            const toolbar = document.querySelector('#name-canvas-toolbar .drawing-toolbar');
            const penBtn = toolbar.querySelector('[title="Stift"]');
            const eraserBtn = toolbar.querySelector('[title="Radiergummi"]');
            
            if (!penBtn.classList.contains('active')) {
                throw new Error('Pen button not marked as active');
            }
            
            Drawing.setToolForCanvas('eraser', 'name-canvas-container');
            
            if (penBtn.classList.contains('active')) {
                throw new Error('Pen button still active after switching to eraser');
            }
            
            return true;
        });
        
        // Test 6: Drawing State Management
        log('<h2>6. Drawing State & Interaction:</h2>');
        
        test('Drawing state tracking', () => {
            // Initially not drawing
            if (Drawing.isDrawing !== false) {
                throw new Error('Initial drawing state should be false');
            }
            
            // Simulate starting drawing
            const mockEvent = {
                target: Drawing.canvasInstances.get('test-canvas-container').canvas,
                clientX: 50,
                clientY: 50
            };
            const ctx = Drawing.canvasInstances.get('test-canvas-container').ctx;
            
            Drawing.startDrawing(mockEvent, ctx);
            
            if (Drawing.isDrawing !== true) {
                throw new Error('Drawing state not updated when starting');
            }
            
            if (!Drawing.lastPoint || typeof Drawing.lastPoint.x !== 'number') {
                throw new Error('Last point not set correctly');
            }
            
            Drawing.stopDrawing();
            
            if (Drawing.isDrawing !== false) {
                throw new Error('Drawing state not reset when stopping');
            }
            
            if (Drawing.lastPoint !== null) {
                throw new Error('Last point not cleared when stopping');
            }
            
            return true;
        });
        
        test('Drawing line creation', () => {
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const ctx = instance.ctx;
            
            // Clear canvas first
            Drawing.clearCanvas('test-canvas-container');
            
            // Simulate a drawing stroke
            const startEvent = {
                target: instance.canvas,
                clientX: 10,
                clientY: 10
            };
            
            const moveEvent = {
                target: instance.canvas,
                clientX: 50,
                clientY: 50
            };
            
            Drawing.setTool('pen');
            Drawing.setPenColor('#000000');
            Drawing.startDrawing(startEvent, ctx);
            Drawing.draw(moveEvent, ctx);
            Drawing.stopDrawing();
            
            // Check if something was drawn by examining image data
            const imageData = ctx.getImageData(0, 0, instance.canvas.width, instance.canvas.height);
            const data = imageData.data;
            
            let hasDrawing = false;
            for (let i = 3; i < data.length; i += 4) { // Check alpha channel
                if (data[i] > 0) {
                    hasDrawing = true;
                    break;
                }
            }
            
            if (!hasDrawing) {
                throw new Error('No drawing detected after simulated stroke');
            }
            
            return true;
        });
        
        // Test 7: Apple Pencil & Pressure Sensitivity
        log('<h2>7. Apple Pencil & Advanced Touch Features:</h2>');
        
        test('Pointer events for Apple Pencil', () => {
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const canvas = instance.canvas;
            
            // Simulate Apple Pencil pointer event
            const pointerEvent = new PointerEvent('pointerdown', {
                pointerType: 'pen',
                pressure: 0.8,
                clientX: 100,
                clientY: 100,
                bubbles: true,
                cancelable: true
            });
            
            // Should not throw error
            try {
                canvas.dispatchEvent(pointerEvent);
            } catch (error) {
                throw new Error('Apple Pencil pointer event handling failed');
            }
            
            return true;
        });
        
        test('Pressure sensitivity handling', () => {
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const ctx = instance.ctx;
            
            Drawing.setPenWidth(4);
            Drawing.setTool('pen');
            
            // Simulate pressure-sensitive pointer move
            const pointerMoveEvent = new PointerEvent('pointermove', {
                pointerType: 'pen',
                pressure: 0.5,
                clientX: 150,
                clientY: 150
            });
            
            // Mock the drawing state
            Drawing.isDrawing = true;
            
            // This should adjust line width based on pressure
            const moveHandler = (e) => {
                if (e.pointerType === 'pen') {
                    const pressureMultiplier = e.pressure || 0.5;
                    const expectedWidth = Math.max(1, Drawing.penWidth * pressureMultiplier);
                    ctx.lineWidth = expectedWidth;
                    
                    if (expectedWidth !== 2) { // 4 * 0.5 = 2
                        throw new Error(`Pressure sensitivity not working: got ${expectedWidth}, expected 2`);
                    }
                }
            };
            
            moveHandler(pointerMoveEvent);
            
            Drawing.isDrawing = false;
            return true;
        });
        
        test('Gesture prevention for iPad', () => {
            const instance = Drawing.canvasInstances.get('test-canvas-container');
            const canvas = instance.canvas;
            
            // Test gesture events (these should be prevented on iPad)
            const gestureEvents = ['gesturestart', 'gesturechange', 'gestureend'];
            
            for (const eventType of gestureEvents) {
                const gestureEvent = new Event(eventType, {
                    bubbles: true,
                    cancelable: true
                });
                
                try {
                    canvas.dispatchEvent(gestureEvent);
                } catch (error) {
                    throw new Error(`Gesture event ${eventType} handling failed`);
                }
            }
            
            return true;
        });
        
        // Test 8: Integration & Error Handling
        log('<h2>8. Integration & Error Handling:</h2>');
        
        test('Multiple canvas instances', () => {
            // Create multiple canvases
            Drawing.initCanvasArea('class-canvas-container', 200, 40);
            
            if (Drawing.canvasInstances.size < 2) {
                throw new Error('Multiple canvas instances not tracked');
            }
            
            // Test independent tool settings
            Drawing.setToolForCanvas('pen', 'test-canvas-container');
            Drawing.setToolForCanvas('eraser', 'class-canvas-container');
            
            const instance1 = Drawing.canvasInstances.get('test-canvas-container');
            const instance2 = Drawing.canvasInstances.get('class-canvas-container');
            
            if (instance1.ctx.globalCompositeOperation === instance2.ctx.globalCompositeOperation) {
                throw new Error('Canvas instances should have independent tool states');
            }
            
            return true;
        });
        
        test('Global tool changes affect all canvases', () => {
            Drawing.setPenColor('#00ff00');
            
            // Check all canvas instances
            Drawing.canvasInstances.forEach(({ ctx }) => {
                // Note: strokeStyle might be set when tool is pen
                if (Drawing.currentTool === 'pen' && ctx.strokeStyle !== '#00ff00') {
                    throw new Error('Global color change not applied to all canvases');
                }
            });
            
            return true;
        });
        
        test('Canvas cleanup on invalid operations', () => {
            // Test operations on removed DOM elements
            const container = document.getElementById('test-canvas-container');
            container.innerHTML = ''; // Remove canvas
            
            // These should not throw errors
            Drawing.clearCanvas('test-canvas-container');
            const data = Drawing.getCanvasData('test-canvas-container');
            
            // Canvas instance should still exist but operations should be safe
            if (!Drawing.canvasInstances.has('test-canvas-container')) {
                throw new Error('Canvas instance removed incorrectly');
            }
            
            return true;
        });
        
        // Final Results
        setTimeout(() => {
            log(`<h2>🎯 Test Results: ${testsPassed}/${testsTotal} tests passed</h2>`);
            
            if (testsPassed === testsTotal) {
                log('<h2 style="color: green">✅ All drawing module tests PASSED!</h2>');
                log('<p>✏️ Canvas creation and initialization working perfectly</p>');
                log('<p>🎨 Drawing tools and state management functional</p>');
                log('<p>📱 Touch and Apple Pencil support properly implemented</p>');
                log('<p>💾 Data export/import for persistence working</p>');
                log('<p>🛠️ Toolbar creation and management operational</p>');
            } else {
                log(`<h2 style="color: red">❌ ${testsTotal - testsPassed} tests FAILED</h2>`);
            }
            
            // Clean up test elements
            Drawing.canvasInstances.clear();
            Drawing.isDrawing = false;
            Drawing.lastPoint = null;
            Drawing.currentTool = 'pen';
        }, 100);
    </script>
</body>
</html>